# Fill in your name, student ID, and email address in this file.
# If you are working in a team, fill out the information for both team 
# members.

# SUBMIT THE LAB ONLY ONCE (from only one partner). This file will be
# automatically parsed in order to give both team members credit for the
# lab.

# You need to fill in the EXERCISE sections describing your solutions
# for Tasks 1, 2, and 3, as well as write the corresponding code.
# If you did one or more extra credit problems, indicate which one in the
# appropriate section below (remove the # sign first). If you have any other
# information you'd like us to know, please add it at the end of the file.

# Partner 1
Name: Jia Dan Duan
Student ID: 604022222
Email: danielduan88@yahoo.com

# Partner 2 (if you're working in a team)
Name: Kenneth Shi
Student ID: 304063313
Email: kenshi@ucla.edu

# EXERCISE 1: What method you used to make your peer download and upload
#    files in parallel?  (~1-3 sentences)

We decided to use the fork() function to parallelize our peer download and
uploads. We would use fork() to spawn a new child thread for each download/upload
that we had. This allowed us to parallize because each child would be able to perform
the download or upload while the parent would be able to spawn more children for other files. 

# EXERCISE 2A: What conditions did you find and fix that would have
#    triggered a buffer overrun bug?  (~1-3 sentences each)

We found that the code 'strcpy(t->filename, filename)' would cause a buffer
overflow, because if we were to have a filename that was the same length or
larger than FILENAMESIZ, we would overwrite the filename buffer. To fix this 
problem, we decided to use strncopy instead of strcpy. Since strncopy has an 
extra paramater where we could specify the size, we could restrict the filename 
size to FILENAMESIZ. 

# EXERCISE 2B: What other robustness problems did you fix?  (~1-3 sentences
#    each)

1. We found that the peers can send endless data when it receives a request from a peer.
We added a maximum file size to stop downloading at and restarting the file session.
The current limit is set at ~1GB and is adjustable in the #define section at the
beginning of the file.

2. We found that the task buffer would fill up before actual file transfer is completed.
It occurs when too many peers try to connect at the same time.
Instead of dynamically resizing, we decided on an optimal number of 52800. 

3. We fixed a problem with an attacker possibly trying to access directories that
aren't the current directory. We did this by checking the filename, and if the filename
had a '/' character, then we knew it was trying to access some other directory. Therefore,
we would report an error if that would happen and exit. 

# EXERCISE 3: Describe the attacks you implemented for "evil mode".  Why
#    are they attacks?  (~3-10 sentences each)

1. We implemented buffer overflow for sending a really long file name. It tries to send the
same bytes over and over with no regards to where the end of the file is. It is an issue
we fixed in our code.

2. We tried to set up a denial of service by sending a whole bunch of connection requests
at the same time. On the host, it should get overloaded with requests and not be able to
handle legitimate requests.

# Extra credit problems
#Extra credit problem: none

# Add any other information you'd like us to know below this line.
